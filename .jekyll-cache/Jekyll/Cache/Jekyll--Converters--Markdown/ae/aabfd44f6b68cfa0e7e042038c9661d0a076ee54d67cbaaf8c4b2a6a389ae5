I"s'<p>The longer you do anything, the more preferences you may develop for that thing. One of these things is making R packages.</p>

<p>One preference I’ve developed is in limiting package dependencies - or at least limiting to the least painful dependencies - in the packages I maintain. Ideally, if a base R solution can be done then do it that way. Everybody has base R packages if they are using R, so you can’t fail there, at least on package installation.</p>

<p>This is largely not about trusting individual packages (<a href="https://simplystatistics.org/2015/11/06/how-i-decide-when-to-trust-an-r-package/">cf. Jeff Leek’s post</a>), but trust does play a role in deciding which packages to use (see <em>choosing among packages that do the same thing</em> below).</p>

<h3 id="why">why?</h3>

<p>There’s sure to be different opinions on this, but this is why I defend this hill:</p>

<ul>
  <li>Why introduce more complexity if it can be avoided?</li>
  <li>It’s one more thing out of your control. sure, in a perfect world package API’s never break, at least after a certain version (v1 or so), but we can’t depend on that.</li>
  <li>Rolling your own solution for a problem (aka function/class/etc.) means its completely under your control</li>
  <li>There’s a lot of great packages out there. However, in my opinion, many packages, including many of my own, are targeted at interactive users, not necessarily optimizing for other packages to use. So even though a package may do X really well, you can also do X on your own if it’s simple enough.</li>
</ul>

<h3 id="base-r-solutions">base R solutions</h3>

<p>Some examples of base R solutions I like to use rather than using an off the shelf package:</p>

<ul>
  <li>Remove <code class="highlighter-rouge">NULL</code> elements from a list. The function <code class="highlighter-rouge">function(l) Filter(Negate(is.null), l)</code> is stolen from <code class="highlighter-rouge">plyr::compact</code> originally. I include it as a utility function in many of my packages. It’s simple base R stuff. Easy peasy.</li>
  <li>Extract string form another string based on a pattern. The function <code class="highlighter-rouge">function(x, y) regmatches(x, regexpr(y, x))</code> is what <code class="highlighter-rouge">stringr::str_extract</code> used to do before it moved to wrapping <code class="highlighter-rouge">stringi</code> functions. I like the pattern of the input first, and your pattern second, but don’t want to import a huge dependency (<code class="highlighter-rouge">stringi</code>) if I know i just need a simple string extraction.</li>
  <li>Infix function <code class="highlighter-rouge">%||%</code>. originally saw this in <code class="highlighter-rouge">dplyr</code>, but now has left that package. the function: <code class="highlighter-rouge">function(x, y) if (is.null(x) || length(x) == 0) y else x</code>. It provides an elegant solution of a in place defined default value for when you can’t be certain of the result. It’s a very brief function, so no need to import a package just for this function.</li>
  <li>Check that a parameter input is of the right type. R doesn’t have type checking like some other languages. we can do it internally within the package though. There are packages to do this (check out <a href="https://github.com/ropensci/assertr">assertr</a>), but instead of importing a package, I do something like the below:</li>
</ul>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assert</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nf">is.null</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">inherits</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">stop</span><span class="p">(</span><span class="n">deparse</span><span class="p">(</span><span class="nf">substitute</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="w"> </span><span class="s2">" must be of class "</span><span class="p">,</span><span class="w">
          </span><span class="n">paste0</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">collapse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">", "</span><span class="p">),</span><span class="w"> </span><span class="n">call.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">FALSE</span><span class="p">)</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>It seems simple enough that I don’t think importing a package is warranted.</p>

<h3 id="choosing-among-packages-that-do-the-same-thing">choosing among packages that do the same thing</h3>

<ul>
  <li>I often need to combine many rows/lists into a data.frame in my packages. <code class="highlighter-rouge">dplyr::bind_rows</code> and <code class="highlighter-rouge">data.table::rbindlist</code> do this (there’s probably others too). I’ve found that <code class="highlighter-rouge">data.table</code> is a slightly/somewhat easier dependency WRT installation, so I commonly use the below function for binding named lists into rows of a <code class="highlighter-rouge">data.frame</code>, with the optional conversion to a <code class="highlighter-rouge">tbl_df</code>.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function(x) {
  tibble::as_tibble((x &lt;- data.table::setDF(
    data.table::rbindlist(x, use.names = TRUE, fill = TRUE, idcol = "id"))
  ))
}
</code></pre></div></div>

<h3 id="other-bits">other bits</h3>

<ul>
  <li><a href="https://github.com/jimhester">Jim Hester</a> did a presentation on the <a href="https://github.com/tidyverse/glue">glue</a> package: <a href="https://rawgit.com/jimhester/presentations/master/2018_07_13-Glue_strings_to_data_with_glue/2018_03_28-Glue_string_to_data_with_glue.html#/glue-is-for-packages">Glue Strings to Data with Glue</a> - and emphasized on one slide that <code class="highlighter-rouge">glue</code> is for packages because it has zero dependencies, is customizable, and fast - all things you want in a dependency in your own package.</li>
  <li>As I was wrapping up this post I found a few papers:
    <ul>
      <li>Claes et al. <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> found that “occurrence of errors in CRAN packages over a period of three months … resulted mostly from updates in the packages’ dependencies …”</li>
      <li>In another paper Plakidas et al. <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> extend the previous finding and say “… this potentially implies a heavy workload for package maintainers when they depend on a package that is frequently updated”</li>
      <li>These statements mirror my hesitation to depend on other packages if in fact X task can be done internally</li>
    </ul>
  </li>
  <li>Contributors: if you do write your own internal functions, or borrow from elsewhere, new contributors to your package may need to understand your internal function instead of an imported function from another package - but the plus side is if the function resides in your own package you can change it easily.</li>
  <li>Rapid development phase: often package development involves a rapid change phase where you want to get to a working prototype first, then refine later. During this development phase it makes sense to use off the shelf packages to get things working. Later, you may want to swap out packages or write your own R or compiled code to speed things up, or introduce different behavior, etc.</li>
</ul>

<h3 id="but">but</h3>

<p>There are of course good reasons to just import the package that’s best at doing X or Y and leave it at that. Sometimes I do that too. I don’t always stay on my hill.</p>

<p>And: Maybe I’m totally wrong here? Maybe I should be at all times using other packages to do X, Y, and Z? Despite the dozens of packages I maintain, I am fully aware I could be completely wrong here.</p>

<p><br /></p>

<hr />

<p>thanks to <a href="https://masalmon.eu/">Maëlle Salmon</a> for helpful advice on this post!</p>

<h3 id="references">references</h3>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Claes, M., Mens, T., &amp; Grosjean, P. (2014). On the maintainability of CRAN packages. 2014 Software Evolution Week - IEEE Conference on Software Maintenance, Reengineering, and Reverse Engineering (CSMR-WCRE). <a href="https://doi.org/10.1109/csmr-wcre.2014.6747183">https://doi.org/10.1109/csmr-wcre.2014.6747183</a> <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Plakidas, K., Schall, D., &amp; Zdun, U. (2017). Evolution of the R software ecosystem: Metrics, relationships, and their impact on qualities. Journal of Systems and Software, 132, 119–146. <a href="https://doi.org/10.1016/j.jss.2017.06.095">https://doi.org/10.1016/j.jss.2017.06.095</a> <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET