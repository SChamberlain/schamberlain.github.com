I"≠*<p>In doing a number of ports of Ruby gems to R (<a href="https://github.com/ropensci/vcr">vcr</a>, <a href="https://github.com/ropensci/webmockr">webmockr</a>), I‚Äôve noticed a few differences between the languages that are fun to dive into, at least for me.</p>

<h2 id="monkey-patching">monkey patching</h2>

<p>Ruby has a nice thing where you can <a href="https://en.wikipedia.org/wiki/Monkey_patch">‚Äúmonkey patch‚Äù</a> classes/methods/etc. in other Ruby libraries. For example, lets say you have Ruby gems <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code>. If <code class="highlighter-rouge">foo</code> has a method <code class="highlighter-rouge">hello</code>, you can override the <code class="highlighter-rouge">hello</code> method in <code class="highlighter-rouge">foo</code> with one from <code class="highlighter-rouge">bar</code>. AFAICT this is acceptable in gems on Rubygems.org and in general in the community.</p>

<p>Monkey patching is technically possible in R, but is not allowed in packages on CRAN (see <code class="highlighter-rouge">?assignInNamespace</code> help for the warnings), even though <a href="https://github.com/search?p=1&amp;q=org%3Acran+assignInNamespace&amp;type=Code">there is some usage in CRAN packages</a>. We can do this using <code class="highlighter-rouge">utils::assignInNamespace</code>. Let‚Äôs say you have an R package <code class="highlighter-rouge">foo</code> and another R package <code class="highlighter-rouge">bar</code>. Here, we can assign a new <code class="highlighter-rouge">hello</code> method to the one already defined in <code class="highlighter-rouge">foo</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the foo::hello method looks like</span><span class="w">
</span><span class="n">hello</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="nf">return</span><span class="p">(</span><span class="s2">"world!"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># make a new hello method</span><span class="w">
</span><span class="n">hello2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">()</span><span class="w"> </span><span class="nf">return</span><span class="p">(</span><span class="s2">"mars!"</span><span class="p">)</span><span class="w">
</span><span class="c1"># override the hello method in foo</span><span class="w">
</span><span class="n">utils</span><span class="o">::</span><span class="n">assignInNamespace</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">,</span><span class="w"> </span><span class="n">hello2</span><span class="p">,</span><span class="w"> </span><span class="s2">"foo"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Try it with any package. It‚Äôs fun.</p>

<p>You can do this in a package, by using a <code class="highlighter-rouge">.onAttach</code> directive.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">.onAttach</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">libname</span><span class="p">,</span><span class="w"> </span><span class="n">pkgname</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">utils</span><span class="o">::</span><span class="n">assignInNamespace</span><span class="p">(</span><span class="s2">"bar"</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="s2">"foo"</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Anyway, monkey patching isn‚Äôt really a thing in R, so that makes it more difficult to port Ruby things to R. The inability to do this in R makes many things much harder. For example, in <a href="https://github.com/ropensci/vcr">vcr</a> and <a href="https://github.com/ropensci/webmockr">webmockr</a> I couldn‚Äôt simply override methods in http libraries they hook into, but have to make changes in the http libraries themselves to support the HTTP mocking - we get there in the end, but it takes much longer, though possibly safer?</p>

<h2 id="0-ruby-vs-1-r-based-indexing">0 (Ruby) vs. 1 (R) based indexing</h2>

<p>Never hurts to keep repeating this.</p>

<h2 id="sequences">sequences</h2>

<p>Ruby has the ability to construct numeric sequences with <code class="highlighter-rouge">..</code> and <code class="highlighter-rouge">...</code>, e.g.,</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># inclusive of second number</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">..</span><span class="mi">3</span>
<span class="n">x</span><span class="p">.</span><span class="nf">to_a</span>
<span class="o">=&gt;</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="c1"># exclusive of second number</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">...</span><span class="mi">3</span>
<span class="n">x</span><span class="p">.</span><span class="nf">to_a</span>
<span class="o">=&gt;</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>AFAIK, in R we can only do inclusive sequences</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="w">
</span><span class="c1">#&gt; [1] 1 2 3</span><span class="w">
</span></code></pre></div></div>

<h2 id="explicit-imports">explicit imports</h2>

<p>In at least Ruby and Python you have to be explicit about saying where to import methods from other files.</p>

<p>Whereas in R you can just use a function/etc. from any other file in the package without stating that you need it. This makes it harder to reason about the dependent functions/etc. needed in any one file. One tool that helps with this is <a href="https://github.com/MangoTheCat/functionMap">functionMap</a> (though last commit in 2016, not sure if maintained anymore, is it G√°bor?).</p>

<p>On a related note, in Ruby we can use global variables like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$foo</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div></div>

<p>From what I understand the above is bad pratice, but I do use them sometimes in my own Ruby stuff.</p>

<p>In R all variables/methods/classes are ‚Äúglobal‚Äù within the namespace of the package.</p>

<h2 id="adding-strings">adding strings</h2>

<p>ugh, I wish R had the ability to add strings together with <code class="highlighter-rouge">+</code>.</p>

<h2 id="-as-a-valid-character">? as a valid character</h2>

<p>um, yes please. I love methods in Ruby like <code class="highlighter-rouge">nil?</code>, <code class="highlighter-rouge">empty?</code>, etc. Such a straight-forward way to indicate intent. Wish we had these in R, but <code class="highlighter-rouge">?</code> isn‚Äôt even a valid character on its own, so not (ever?) gonna happen.</p>

<h2 id="classes">Classes</h2>

<p>R‚Äôs closest class system to Ruby (that I‚Äôm willing to use) is <a href="https://cran.rstudio.com/web/packages/R6/">R6</a> from Winston Chang. Using <code class="highlighter-rouge">R6</code> makes it a bit easier to port from Ruby or a similar language as you can directly translate classes that have public vs. private methods, an initializer, print method, etc. Plus, with any sufficiently complex R package, using <code class="highlighter-rouge">R6</code> makes it much easier to manage the complexity.</p>

<h2 id="rubys-">Ruby‚Äôs ||=</h2>

<p>In ruby this operator means essentially ‚Äúif a is undefined or falsey, evaluate b and set a to the result‚Äù. In R there‚Äôs AFAIK nothing like this. <code class="highlighter-rouge">||=</code> was used extensively in the Ruby gems I was porting, making the ported version in R more verbose. I could do in R <code class="highlighter-rouge">a %||% b</code> (where <code class="highlighter-rouge">%||% = function(x, y) if (is.null(x) || !x) y else x</code>) essentially doing ‚Äúif a is null, undefined or falsey, evaluate b‚Äù; but then I have to still assign the result, giving <code class="highlighter-rouge">a = a %||% b</code>.</p>

<h2 id="splat-args">splat args</h2>

<p>The splat operator is used heavily in Ruby. It looks like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="nb">p</span> <span class="n">args</span>
<span class="k">end</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># =&gt; [1, 2, 3]</span>
</code></pre></div></div>

<p>In R the most similar thing we have is the ellipsis, so</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">function</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">...</span><span class="p">)</span><span class="w">
</span><span class="n">foo</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">)</span><span class="w">
</span><span class="c1">#&gt; [1] 1 2 3</span><span class="w">
</span></code></pre></div></div>

<p>Ruby splat args won‚Äôt trip you up if you know how to do this conversion. Of course there‚Äôs <code class="highlighter-rouge">rlang</code> and such in R as well.</p>

:ET