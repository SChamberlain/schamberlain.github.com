#' }
#' @export
col_classification <- function(name = NULL, id = NULL, format = NULL, start = NULL,
checklist = NULL, url = "http://www.catalogueoflife.org/col/webservice")
{
doit <- function(x, y) {
if(is.null(checklist)){NULL} else {
cc <- match.arg(checklist, choices=c(2012,2011,2010,2009,2008,2007))
if(cc %in% c(2012,2011,2010)){
url <- gsub("col", paste("annual-checklist/", cc, sep=""), url)
} else
{
url <- "http://webservice.catalogueoflife.org/annual-checklist/year/search.php"
url <- gsub("year", cc, url)
}
}
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
out <- getForm(url, .params = args)
tt <- xmlParse(out)
classif_id <- xpathSApply(tt, "//classification//id", xmlValue)
classif_name <- xpathSApply(tt, "//classification//name", xmlValue)
classif_rank <- xpathSApply(tt, "//classification//rank", xmlValue)
data.frame(classif_id, classif_name, classif_rank)
}
safe_doit <- plyr::failwith(NULL, doit)
if(is.null(id)){ llply(name, safe_doit, y=NULL) } else { llply(id, safe_doit, x=NULL) }
}
#' Search Catalogue of Life for taxonomic classifications.
#'
#' @import RCurl XML plyr
#' @param name The string to search for. Only exact matches found the name given
#' 		will be returned, unless one or wildcards are included in the search string.
#' 		An * (asterisk) character denotes a wildcard; a % (percentage) character
#' 		may also be used. The name must be at least 3 characters long, not counting
#' 		wildcard characters.
#' @param id The record ID of the specific record to return (only for scientific
#' 		names of species or infraspecific taxa)
#' @param format format of the results returned. Valid values are format=xml and
#' 		format=php; if the format parameter is omitted, the results are returned in
#' 		the default XML format. If format=php then results are returned as a PHP
#' 		array in serialized string format, which can be converted back to an array
#' 		in PHP using the unserialize command
#' @param start The first record to return. If omitted, the results are returned
#' 		from the first record (start=0). This is useful if the total number of
#' 		results is larger than the maximum number of results returned by a single
#' 		Web service query (currently the maximum number of results returned by a
#' 		single query is 500 for terse queries and 50 for full queries).
#' @param checklist The year of the checklist to query, if you want a specific
#' 		year's checklist instead of the lastest as default (numeric).
#' @param url The base COL url for the function (should be left to default).
#' @details You must provide one of name or id. The other parameters (format
#' 		and start) are optional.
#' @return A list of data.frame's.
#' @examples \dontrun{
#' # A basic example
#' col_children(name="Apis")
#'
#' # An example where there is no classification
#' col_children(id=11935941)
#'
#' # Use a specific year's checklist
#' col_children(name="Apis", checklist="2012")
#' col_children(name="Apis", checklist="2009")
#'
#' # Pass in many names or many id's
#' col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
#' }
#' @export
col_children <- function(name = NULL, id = NULL, format = NULL, start = NULL,
checklist = NULL, url = "http://www.catalogueoflife.org/col/webservice")
{
func <- function(x, y) {
if(is.null(checklist)){NULL} else {
cc <- match.arg(checklist, choices=c(2012,2011,2010,2009,2008,2007))
if(cc %in% c(2012,2011,2010)){
url <- gsub("col", paste("annual-checklist/", cc, sep=""), url)
} else
{
url <- "http://webservice.catalogueoflife.org/annual-checklist/year/search.php"
url <- gsub("year", cc, url)
}
}
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
out <- getForm(url, .params = args)
tt <- xmlParse(out)
childtaxa_id <- xpathSApply(tt, "//child_taxa//id", xmlValue)
childtaxa_name <- xpathSApply(tt, "//child_taxa//name", xmlValue)
childtaxa_rank <- xpathSApply(tt, "//child_taxa//rank", xmlValue)
data.frame(childtaxa_id, childtaxa_name, childtaxa_rank)
}
safe_func <- plyr::failwith(NULL, func)
if(is.null(id)){ llply(name, safe_func, y=NULL) } else { llply(id, safe_func, x=NULL) }
}
col_children(name="Apis")
col_children(id=11935941)
col_children(name="Apis", checklist="2012")
col_children(name="Apis", checklist="2009")
col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
#' Search Catalogue of Life for taxonomic classifications.
#'
#' @import RCurl XML plyr
#' @param name The string to search for. Only exact matches found the name given
#' 		will be returned, unless one or wildcards are included in the search string.
#' 		An * (asterisk) character denotes a wildcard; a % (percentage) character
#' 		may also be used. The name must be at least 3 characters long, not counting
#' 		wildcard characters.
#' @param id The record ID of the specific record to return (only for scientific
#' 		names of species or infraspecific taxa)
#' @param format format of the results returned. Valid values are format=xml and
#' 		format=php; if the format parameter is omitted, the results are returned in
#' 		the default XML format. If format=php then results are returned as a PHP
#' 		array in serialized string format, which can be converted back to an array
#' 		in PHP using the unserialize command
#' @param start The first record to return. If omitted, the results are returned
#' 		from the first record (start=0). This is useful if the total number of
#' 		results is larger than the maximum number of results returned by a single
#' 		Web service query (currently the maximum number of results returned by a
#' 		single query is 500 for terse queries and 50 for full queries).
#' @param checklist The year of the checklist to query, if you want a specific
#' 		year's checklist instead of the lastest as default (numeric).
#' @param url The base COL url for the function (should be left to default).
#' @details You must provide one of name or id. The other parameters (format
#' 		and start) are optional.
#' @return A list of data.frame's.
#' @examples \dontrun{
#' # A basic example
#' col_children(name="Apis")
#'
#' # An example where there is no classification
#' col_children(id=11935941)
#'
#' # Use a specific year's checklist
#' col_children(name="Apis", checklist="2012")
#' col_children(name="Apis", checklist="2009")
#'
#' # Pass in many names or many id's
#' col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
#' }
#' @export
col_children <- function(name = NULL, id = NULL, format = NULL, start = NULL,
checklist = NULL, url = "http://www.catalogueoflife.org/col/webservice")
{
func <- function(x, y) {
if(is.null(checklist)){NULL} else {
cc <- match.arg(checklist, choices=c(2012,2011,2010,2009,2008,2007))
if(cc %in% c(2012,2011,2010)){
url <- gsub("col", paste("annual-checklist/", cc, sep=""), url)
} else
{
url <- "http://webservice.catalogueoflife.org/annual-checklist/year/search.php"
url <- gsub("year", cc, url)
}
}
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
out <- getForm(url, .params = args)
tt <- xmlParse(out)
childtaxa_id <- xpathSApply(tt, "//child_taxa//id", xmlValue)
childtaxa_name <- xpathSApply(tt, "//child_taxa//name", xmlValue)
childtaxa_rank <- xpathSApply(tt, "//child_taxa//rank", xmlValue)
data.frame(childtaxa_id, childtaxa_name, childtaxa_rank)
}
safe_func <- plyr::failwith(NULL, func)
if(is.null(id)){
temp <- llply(name, safe_func, y=NULL)
names(temp) <- id
temp
} else {
temp <- llply(id, safe_func, x=NULL)
names(temp) <- name
temp
}
}
col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
#' Search Catalogue of Life for taxonomic classifications.
#'
#' @import RCurl XML plyr
#' @param name The string to search for. Only exact matches found the name given
#' 		will be returned, unless one or wildcards are included in the search string.
#' 		An * (asterisk) character denotes a wildcard; a % (percentage) character
#' 		may also be used. The name must be at least 3 characters long, not counting
#' 		wildcard characters.
#' @param id The record ID of the specific record to return (only for scientific
#' 		names of species or infraspecific taxa)
#' @param format format of the results returned. Valid values are format=xml and
#' 		format=php; if the format parameter is omitted, the results are returned in
#' 		the default XML format. If format=php then results are returned as a PHP
#' 		array in serialized string format, which can be converted back to an array
#' 		in PHP using the unserialize command
#' @param start The first record to return. If omitted, the results are returned
#' 		from the first record (start=0). This is useful if the total number of
#' 		results is larger than the maximum number of results returned by a single
#' 		Web service query (currently the maximum number of results returned by a
#' 		single query is 500 for terse queries and 50 for full queries).
#' @param checklist The year of the checklist to query, if you want a specific
#' 		year's checklist instead of the lastest as default (numeric).
#' @param url The base COL url for the function (should be left to default).
#' @details You must provide one of name or id. The other parameters (format
#' 		and start) are optional.
#' @return A list of data.frame's.
#' @examples \dontrun{
#' # A basic example
#' col_children(name="Apis")
#'
#' # An example where there is no classification
#' col_children(id=11935941)
#'
#' # Use a specific year's checklist
#' col_children(name="Apis", checklist="2012")
#' col_children(name="Apis", checklist="2009")
#'
#' # Pass in many names or many id's
#' col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
#' }
#' @export
col_children <- function(name = NULL, id = NULL, format = NULL, start = NULL,
checklist = NULL, url = "http://www.catalogueoflife.org/col/webservice")
{
func <- function(x, y) {
if(is.null(checklist)){NULL} else {
cc <- match.arg(checklist, choices=c(2012,2011,2010,2009,2008,2007))
if(cc %in% c(2012,2011,2010)){
url <- gsub("col", paste("annual-checklist/", cc, sep=""), url)
} else
{
url <- "http://webservice.catalogueoflife.org/annual-checklist/year/search.php"
url <- gsub("year", cc, url)
}
}
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
out <- getForm(url, .params = args)
tt <- xmlParse(out)
childtaxa_id <- xpathSApply(tt, "//child_taxa//id", xmlValue)
childtaxa_name <- xpathSApply(tt, "//child_taxa//name", xmlValue)
childtaxa_rank <- xpathSApply(tt, "//child_taxa//rank", xmlValue)
data.frame(childtaxa_id, childtaxa_name, childtaxa_rank)
}
safe_func <- plyr::failwith(NULL, func)
if(is.null(id)){
temp <- llply(name, safe_func, y=NULL)
names(temp) <- name
temp
} else {
temp <- llply(id, safe_func, x=NULL)
names(temp) <- id
temp
}
}
col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
out <- col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
out$Apis # get just the output you want
ldply(out)
out <- col_classification(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
out$Apis # get just the output you want
ldply(out) # or combine to one data.frame
col_classification(name="Apis", checklist="2012")
name=c("Buteo","Apis","Accipiter","asdf")
checklist="2012"
url = "http://www.catalogueoflife.org/col/webservice"
cc <- match.arg(checklist, choices=c(2012,2011,2010,2009,2008,2007))
cc
url <- gsub("col", paste("annual-checklist/", cc, sep=""), url)
url
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
args
x <- name[[1]]
x
id <- NULL
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
y <- id
y
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
args
out <- getForm(url, .params = args)
tt <- xmlParse(out)
tt
classif_id <- xpathSApply(tt, "//classification//id", xmlValue)
classif_name <- xpathSApply(tt, "//classification//name", xmlValue)
classif_rank <- xpathSApply(tt, "//classification//rank", xmlValue)
data.frame(classif_id, classif_name, classif_rank)
x <- name[[2]]
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
args
out <- getForm(url, .params = args)
tt <- xmlParse(out)
classif_id <- xpathSApply(tt, "//classification//id", xmlValue)
classif_name <- xpathSApply(tt, "//classification//name", xmlValue)
classif_rank <- xpathSApply(tt, "//classification//rank", xmlValue)
data.frame(classif_id, classif_name, classif_rank)
func <- function(x, y) {
if(is.null(checklist)){NULL} else {
cc <- match.arg(checklist, choices=c(2012,2011,2010,2009,2008,2007))
if(cc %in% c(2012,2011,2010)){
url <- gsub("col", paste("annual-checklist/", cc, sep=""), url)
} else
{
url <- "http://webservice.catalogueoflife.org/annual-checklist/year/search.php"
url <- gsub("year", cc, url)
}
}
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
out <- getForm(url, .params = args)
tt <- xmlParse(out)
classif_id <- xpathSApply(tt, "//classification//id", xmlValue)
classif_name <- xpathSApply(tt, "//classification//name", xmlValue)
classif_rank <- xpathSApply(tt, "//classification//rank", xmlValue)
data.frame(classif_id, classif_name, classif_rank)
}
safe_func <- plyr::failwith(NULL, func)
name
llply(name, safe_func, y=NULL)
out <- col_classification(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
out
name
temp <- llply(name, safe_func, y=NULL)
temp
names(temp) <- name
temp
id
library(taxize)
#' Search Catalogue of Life for taxonomic classifications.
#'
#' @import RCurl XML plyr
#' @param name The string to search for. Only exact matches found the name given
#' 		will be returned, unless one or wildcards are included in the search string.
#' 		An * (asterisk) character denotes a wildcard; a % (percentage) character
#' 		may also be used. The name must be at least 3 characters long, not counting
#' 		wildcard characters.
#' @param id The record ID of the specific record to return (only for scientific
#' 		names of species or infraspecific taxa)
#' @param format format of the results returned. Valid values are format=xml and
#' 		format=php; if the format parameter is omitted, the results are returned in
#' 		the default XML format. If format=php then results are returned as a PHP
#' 		array in serialized string format, which can be converted back to an array
#' 		in PHP using the unserialize command
#' @param start The first record to return. If omitted, the results are returned
#' 		from the first record (start=0). This is useful if the total number of
#' 		results is larger than the maximum number of results returned by a single
#' 		Web service query (currently the maximum number of results returned by a
#' 		single query is 500 for terse queries and 50 for full queries).
#' @param checklist The year of the checklist to query, if you want a specific
#' 		year's checklist instead of the lastest as default (numeric).
#' @param url The base COL url for the function (should be left to default).
#' @details You must provide one of name or id. The other parameters (format
#' 		and start) are optional.
#' @return A list of data.frame's.
#' @examples \dontrun{
#' # A basic example
#' col_classification(name="Apis")
#'
#' # An example where there is no classification
#' col_classification(id=11935941)
#'
#' # Use a specific year's checklist
#' col_classification(name="Apis", checklist="2012")
#' col_classification(name="Apis", checklist="2009")
#'
#' # Pass in many names or many id's
#' out <- col_classification(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
#' out$Apis # get just the output you want
#' ldply(out) # or combine to one data.frame
#' }
#' @export
col_classification <- function(name = NULL, id = NULL, format = NULL, start = NULL,
checklist = NULL, url = "http://www.catalogueoflife.org/col/webservice")
{
func <- function(x, y) {
if(is.null(checklist)){NULL} else {
cc <- match.arg(checklist, choices=c(2012,2011,2010,2009,2008,2007))
if(cc %in% c(2012,2011,2010)){
url <- gsub("col", paste("annual-checklist/", cc, sep=""), url)
} else
{
url <- "http://webservice.catalogueoflife.org/annual-checklist/year/search.php"
url <- gsub("year", cc, url)
}
}
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
out <- getForm(url, .params = args)
tt <- xmlParse(out)
classif_id <- xpathSApply(tt, "//classification//id", xmlValue)
classif_name <- xpathSApply(tt, "//classification//name", xmlValue)
classif_rank <- xpathSApply(tt, "//classification//rank", xmlValue)
data.frame(classif_id, classif_name, classif_rank)
}
safe_func <- plyr::failwith(NULL, func)
if(is.null(id)){
temp <- llply(name, safe_func, y=NULL)
names(temp) <- name
temp
} else {
temp <- llply(id, safe_func, x=NULL)
names(temp) <- id
temp
}
}
out <- col_classification(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
out
out$Apis # get just the output you want
ldply(out) # or combine to one data.frame
#' Search Catalogue of Life for taxonomic classifications.
#'
#' @import RCurl XML plyr
#' @param name The string to search for. Only exact matches found the name given
#' 		will be returned, unless one or wildcards are included in the search string.
#' 		An * (asterisk) character denotes a wildcard; a % (percentage) character
#' 		may also be used. The name must be at least 3 characters long, not counting
#' 		wildcard characters.
#' @param id The record ID of the specific record to return (only for scientific
#' 		names of species or infraspecific taxa)
#' @param format format of the results returned. Valid values are format=xml and
#' 		format=php; if the format parameter is omitted, the results are returned in
#' 		the default XML format. If format=php then results are returned as a PHP
#' 		array in serialized string format, which can be converted back to an array
#' 		in PHP using the unserialize command
#' @param start The first record to return. If omitted, the results are returned
#' 		from the first record (start=0). This is useful if the total number of
#' 		results is larger than the maximum number of results returned by a single
#' 		Web service query (currently the maximum number of results returned by a
#' 		single query is 500 for terse queries and 50 for full queries).
#' @param checklist The year of the checklist to query, if you want a specific
#' 		year's checklist instead of the lastest as default (numeric).
#' @param url The base COL url for the function (should be left to default).
#' @details You must provide one of name or id. The other parameters (format
#' 		and start) are optional.
#' @return A list of data.frame's.
#' @examples \dontrun{
#' # A basic example
#' col_children(name="Apis")
#'
#' # An example where there is no classification
#' col_children(id=11935941)
#'
#' # Use a specific year's checklist
#' col_children(name="Apis", checklist="2012")
#' col_children(name="Apis", checklist="2009")
#'
#' # Pass in many names or many id's
#' out <- col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
#' out$Apis # get just the output you want
#' ldply(out) # or combine to one data.frame
#' }
#' @export
col_children <- function(name = NULL, id = NULL, format = NULL, start = NULL,
checklist = NULL, url = "http://www.catalogueoflife.org/col/webservice")
{
func <- function(x, y) {
if(is.null(checklist)){NULL} else {
cc <- match.arg(checklist, choices=c(2012,2011,2010,2009,2008,2007))
if(cc %in% c(2012,2011,2010)){
url <- gsub("col", paste("annual-checklist/", cc, sep=""), url)
} else
{
url <- "http://webservice.catalogueoflife.org/annual-checklist/year/search.php"
url <- gsub("year", cc, url)
}
}
args <- compact(list(name=x, id=y, format=format, response="full", start=start))
out <- getForm(url, .params = args)
tt <- xmlParse(out)
childtaxa_id <- xpathSApply(tt, "//child_taxa//id", xmlValue)
childtaxa_name <- xpathSApply(tt, "//child_taxa//name", xmlValue)
childtaxa_rank <- xpathSApply(tt, "//child_taxa//rank", xmlValue)
data.frame(childtaxa_id, childtaxa_name, childtaxa_rank)
}
safe_func <- plyr::failwith(NULL, func)
if(is.null(id)){
temp <- llply(name, safe_func, y=NULL)
names(temp) <- name
temp
} else {
temp <- llply(id, safe_func, x=NULL)
names(temp) <- id
temp
}
}
out <- col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
out$Apis # get just the output you want
ldply(out) # or combine to one data.frame
col_children(name=c(6848054,6848066,6848095), checklist="2012")
out <- col_children(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
out <- col_classification(name=c("Buteo","Apis","Accipiter","asdf"), checklist="2012")
ldply(out) # or combine to one data.frame
out <- col_children(name=c(2346405,2344165,2346405), checklist="2012")
ldply(out) # combine to one data.frame
out <- col_children(id=c(2346405,2344165,2346405), checklist="2012")
ldply(out) # combine to one data.frame
library(roxygen2); library(testthat)
roxygenise(taxize)
taxize <- "/Users/ScottMac/github/ropensci/taxize_"
roxygenise(taxize)
col_classification(name="Apis")
col_children(name="Apis")
library(rgbif)
occurrencelist(scientificname = 'Accipiter erythronemius', coordinatestatus = TRUE, maxresults = 5)
occurrencelist(scientificname = 'Accipiter erythronemius', coordinatestatus = TRUE, maxresults = 100)
occurrencelist(scientificname = 'Junco hyemalis', coordinatestatus = TRUE, maxresults = 100)
splist <- c('Accipiter erythronemius', 'Junco hyemalis', 'Aix sponsa')
out <- lapply(splist, function(x) occurrencelist(x, coordinatestatus = T, maxresults = 100))
out
length(out)
splist
out <- llply(splist, function(x) occurrencelist(x, coordinatestatus = T, maxresults = 100))
splist <- c("Accipiter erythronemius", "Junco hyemalis", "Aix sponsa", "Haliaeetus leucocephalus",
"Corvus corone", "Threskiornis molucca", "Merops malimbicus")
out <- llply(splist, function(x) occurrencelist(x, coordinatestatus = T, maxresults = 100))
names(out) <- splist # name each data.frame with the species names
setwd("/Users/ScottMac/github/SChamberlain/schamberlain.github.com/_posts")
knitpost("/Users/ScottMac/github/SChamberlain/schamberlain.github.com/_drafts/2012-12-10-shiny-r.Rmd")
knitpost("/Users/ScottMac/github/SChamberlain/schamberlain.github.com/_drafts/2012-12-10-shiny-r.Rmd")
knitpost("/Users/ScottMac/github/SChamberlain/schamberlain.github.com/_drafts/2012-12-10-shiny-r.Rmd")
knitpost("/Users/ScottMac/github/SChamberlain/schamberlain.github.com/_drafts/2012-12-10-shiny-r.Rmd")
install_github('taxize_', 'ropensci')
